# YamlFlow

Reactive YAML config management with hash-based reloading and async callbacks.

## Requirements

- Java 21+
- SnakeYAML (provided by runtime environment)

## Installation

```bash
mvn clean install
```

```xml
<dependency>
    <groupId>me.verschuls.ylf</groupId>
    <artifactId>yamlflow</artifactId>
    <version>1.0</version>
</dependency>
```

## Features

- **Hash-based reloading** - Only reloads when file content changes
- **Async initialization** - Non-blocking config loading with CompletableFuture
- **Reload callbacks** - React to config changes
- **Thread-safe** - All operations are properly synchronized
- **Bulk loading** - Load multiple configs from a directory

## CM - Single Config Management

Use `CM` for named config files (settings.yml, messages.yml, etc.)

```java
public class ServerConfig extends BaseConfig<ServerConfig.Data> {
    public ServerConfig(Path dir, Executor executor) {
        super(dir, "server", Data.class, executor);
    }

    @Header("Server Configuration")
    @Footer("End of config")
    @Configuration
    public static class Data extends BaseConfig.Data {
        public String host = "localhost";
        public int port = 8080;
    }
}

// Register
CM.register(new ServerConfig(Path.of("./config"), executor));

// Wait for init
CM.onInit(ServerConfig.class).thenAccept(data -> {
    System.out.println("Server: " + data.host + ":" + data.port);
});

// Get data (after init)
ServerConfig.Data data = CM.get(ServerConfig.class);

// Reload & callbacks
CM.reload(ServerConfig.class);
CM.onReload(ServerConfig.class, data -> System.out.println("Reloaded!"));
```

## CMI - Bulk Config Loading

Use `CMI` for loading multiple similar configs from a directory (players/, kits/, etc.)

```java
@Configuration
public class PlayerData {
    public String name = "Unknown";
    public int level = 1;
}

CMI<String, PlayerData> players = new CMI<>(
    Path.of("./players"),
    PlayerData.class,
    CIdentifier.fileName(),
    CFilter.none(),
    executor
);

// Access configs
Optional<PlayerData> player = players.get("steve");
HashMap<String, PlayerData> all = players.get();

// Create & save
PlayerData newPlayer = players.create("alex", "alex");
newPlayer.name = "Alex";
players.save("alex", newPlayer);

// Reload
players.reload();
players.onReload(all -> System.out.println("Reloaded " + all.size() + " players"));
```

## CIdentifier - Key Strategies

Control how configs are identified in CMI:

```java
// File name as key: "player.yml" -> "player"
CIdentifier.fileName()

// Parse file name as UUID: "550e8400-e29b-...yml" -> UUID
CIdentifier.fileNameUUID()

// Auto-increment IDs: 0, 1, 2, ...
CIdentifier.simpleID(new AtomicInteger())

// Custom logic
(file, config) -> config.customId
```

## CFilter - File Filtering

Filter which files to load:

```java
// Load all files
CFilter.none()

// Skip files like "_template_.yml"
CFilter.underScores()

// Custom filter (return true to exclude)
(file, config) -> file.getName().startsWith("backup")
```

## Header & Footer Annotations

Add headers/footers to generated YAML files:

```java
@Header("=== My Config ===\nEdit with care")
@Footer("Generated by YamlFlow")
@Configuration
public static class Data extends BaseConfig.Data {
    public String value = "default";
}
```

Output:
```yaml
# === My Config ===
# Edit with care

value: default

# Generated by YamlFlow
```

## Coming Soon

- **Versioning** - Config migration between versions
- **CMI Builder** - Fluent builder pattern for CMI configuration
- **Async CMI** - Non-blocking bulk config loading
- **Optimizations** - Performance improvements
- ...and more